#!/usr/bin/env perl

use Modern::Perl;
use Getopt::Std;
require IO::File;
require Text::CSV;
require WWW::Mechanize;
require URI::_foreign;

my $main = __PACKAGE__;

our $opt_o;
getopt('o');

my $csv_path = shift @ARGV;
unless ($csv_path) {
    $class->HELP_MESSAGE();
    exit;
}

my @suggested_feeds = $main->load_instapaper_csv($csv_path);

if ($opt_o) {
    $class->export_opml($opt_o, @suggested_feeds);
}

sub HELP_MESSAGE {
    say("Usage: $0 [-o <opml_output>] instapaper-export.csv");
}

sub VERSION_MESSAGE {
    say("alpha");
}

sub load_instapaper_csv {
    my $class = shift;
    my $file_path = shift;

    my $mech = WWW::Mechanize->new();
    my $csv = Text::CSV->new({binary => 1});

    my $preferred_feeds = {};
    my $file = IO::File->new($file_path, 'r');
    while (my $row = $csv->getline($file)) {
        my ($url, $title, $selection, $folder) = @$row;

        next unless $folder eq 'Starred';

        eval { $mech->get($url) };
        if (my $error = $@) {
            say(STDERR "Exception during get ($url): $error");
            next;
        }

        my $preferred_feed = eval { $class->find_preferred_feed($mech) };
        if (my $error = $@) {
            say(STDERR "Exception during find_preferred_feed ($url): $error");
            next;
        }
        if ($preferred_feed) {
            $preferred_feeds->{$class->abs_url($preferred_feed)}{count}++;
            $preferred_feeds->{$class->abs_url($preferred_feed)}{feed} = $preferred_feed;
        }
    }

    my @suggested_feeds;
    for my $feed_url (keys %$preferred_feeds) {
        say($preferred_feeds->{$feed_url}{count} . ' ' . $feed_url);
        push @suggested_feeds, $preferred_feeds->{$feed_url}{feed};
    }
    return @suggested_feeds;
}

sub url_host {
    my $class = shift;
    my $mech = shift;
    my $url_host = $mech->uri->host;
    $url_host =~ s/^www\.//;
    return $url_host;
}

sub find_preferred_feed {
    my $class = shift;
    my $mech = shift;

    my $url = $mech->uri;
    my $url_host = $class->url_host($mech);
    my @feeds = $class->feeds($mech);

    unless (@feeds) {
        say(STDERR "Unable to find preferred feed for ($url): no feeds found.");
        return;
    }

    if (@feeds == 1) {
        return shift @feeds;
    }

    my @feedburner_feeds = grep { $_->URI->abs->host =~ /feeds\d*\.feedburner\.com/ } @feeds;
    if (@feedburner_feeds == 1) {
        return shift @feedburner_feeds;
    } elsif (@feedburner_feeds) {
        say(STDERR "Unable to find preferred feed for ($url): multiple FeedBurner feeds found:\n\t" . join("\n\t", map { $class->abs_url($_) } @feedburner_feeds));
        return;
    }

    my @url_host_feeds = grep { $_->URI->abs->host =~ /$url_host/ } @feeds;
    if (@url_host_feeds) {
        @url_host_feeds = sort { length($class->abs_url($a)) <=> length($class->abs_url($b)) } @url_host_feeds;
        return shift @url_host_feeds;
    }

    say(STDERR "Unable to find preferred feed for ($url): no FeedBurner or $url_host feeds found:\n\t" . join("\n\t", map { $class->abs_url($_) } @feeds));
    return;
}

sub abs_url {
    my $class = shift;
    my $link = shift;
    return $link->URI->abs->as_string;
}

sub feeds {
    my $class = shift;
    my $mech = shift;

    my @links = $mech->links();
    my @feeds = grep { exists $_->attrs->{type} && $_->attrs->{type} =~ /application\/(rss|atom)\+xml/ } @links;

    my %seen = ();
    @feeds = grep { ! $seen{$class->abs_url($_)} ++ } @feeds;

    return @feeds;
}

sub export_opml {
    my $class = shift;
    my $opml_path = shift;
    my @feeds = @_;

    require XML::OPML;
    my $opml = XML::OPML->new();

    $opml->head(
        title => 'Instapaper Feed Suggester',
    );

    for my $feed (@feeds) {
        $opml->insert_outline(
            group => 'Instapaper Feed Suggester',
            type => 'rss',
            xmlUrl => $class->abs_url($feed),
#            title => '',
#            text => '',
#            htmlUrl => '',
        );
    }

    $opml->save($opml_path);
}
